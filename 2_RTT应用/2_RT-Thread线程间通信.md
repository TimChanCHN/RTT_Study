# RT-Thread线程间通信
## 1.消息队列
### 1.概念
1. 消息队列是一种用于线程间、线程与中断之间通信的数据结构；
2. 线程从消息队列中读取信息时，若消息队列为空，则挂起线程，或者指定延时timeout，直到队列中有新消息，挂起的线程会被唤醒并处理新消息；
3. 消息队列是异步通信方式，并遵循着先入先出的原则；
4. 消息队列有以下特性：
   1. 支持先进先出排队和优先级排队，支持异步读写工作方式；
   2. 支持超时读机制；
   3. 支持发送紧急消息，即往队列头发消息；
   4. 消息长度只要不是超过队列节点最大值都可以进行通信；
   5. 队列使用结束后，需要通过删除队列操作释放内存函数回收

### 2.消息队列运作机制
1. 消息队列的初始化
   1. 创建消息队列对象控制块
   2. 给消息队列分配一块内存，组织成空闲消息链表，内存大小=(消息大小+消息头)*消息队列容量
   3. 初始化消息队列，此时消息队列为空
2. 消息队列控制块
   1. 消息队列名称
   2. 内存缓冲区
   3. 消息大小
   4. 队列长度
   5. 消息索引
   6. 消息链表头尾、消息框
   7. 空闲消息框链表(链表中的消息框总数是消息队列长度)
3. 发消息流程
   1. 消息队列先从空闲消息链表上取下一个空闲消息块
   2. 线程/中断发送的消息内容赋值到消息块上
   3. 挂接该消息到消息链表尾部
   4. 当消息列表为空时才能发送，否则会返回一个错误码`-RT_EFULL`
   5. 发送紧急消息，是把该消息块挂接到队列首部
4. 读消息流程
   1. 根据消息队列控制块的`entry`判断是否有消息读取
   2. 读取队列头部的消息，存放到线程/中断对应的缓存中
   3. 队列头部抛弃，队列头更新到队列链表的下一个元素
   4. 释放链表头的内存
   
### 3.消息队列阻塞机制
1. 为了保证每个线程读取消息队列时可以正常完成读写操作时不受后来线程干扰，需要增加消息队列的阻塞机制
2. 线程读消息队列的操作
   1. 不阻塞：检测到队列无消息则退出读消息队列
   2. 定时等待:等待指定时间，当超时后退出读消息队列
   3. 阻塞等待:一直等待，指导消息队列有了消息
3. 只有读消息才可以阻塞，写消息不能阻塞，因为写消息可能是中断服务程序执行，中断不允许有阻塞的情况发生

### 4.常用消息队列函数
1. 创建消息队列
   1. `rt_mq_create`
2. 删除消息队列
   1. `rt_mq_delete`
3. 发送消息队列
   1. ` rt_mq_send`
4. 接受消息队列
   1. `rt_mq_recv`

### 5.消息队列注意事项
1. 对消息队列进行发送、接收、删除等操作前必须先创建消息队列；
2. 接收消息队列是，必须要先创建一块内存用于接收消息队列，否则会发生非法地址错误
3. 接收消息队列中的消息是拷贝的方式，读取消息的地址必须保证能够存放消息的大小

## 2.信号量
### 1. 基本概念
1. 信号量是线程间通信的一中机制，实现线程之间的同步或临界资源的互斥访问；
2. 信号量的计数值用于对应有效的资源数
   1. 0:表示暂时无可用信号量资源，可能存在在此信号量中阻塞的线程
   2. 正值:表示有一个或者多个release释放信号量的操作
3. 信号量可用于同步或者互斥
   1. 互斥:信号量创建后信号量的个数是满的(为1)，线程在使用临界资源时，先获取信号量，使其变空，从而其他线程无法访问该信号量从而进入阻塞，保证了临界资源的安全；但是有可能会导致优先级翻转；
   2. 同步:信号量在创建后被置为空，线程1取信号量而阻塞，线程2在某种条件发生后，释放信号量，从而线程1进入就绪态，若线程1的优先级最高，则线程1会立马执行，从而实现了两个线程之间的同步。
4. 信号量还可以用作计数型信号量，如果信号量的值为n，则可以有n个线程同时访问该信号量，n个之后的线程则挂起，阻塞等待信号量的释放

### 2.信号量的使用
1. 二值信号量只有0/1两个值，初始值为0时，用于同步，初始值为1时，用于互斥；
2. 不管是同步还是互斥，二值信号量乃至信号量都是同样的效果:线程读非零的信号量，可以正常访问，线程读零的信号量，阻塞等待线程的释放；
3. 计数信号量允许多个线程获取信号量访问共享资源，但是线程的最大数目是有所限制的；
4. 当访问计数信号量的线程超过限制时，超过限制数量的线程会挂起阻塞；

### 3.信号量控制块
1. 如同线程控制块的结构体，用于描述信号量的基本特性
   ```c
    struct rt_semaphore {
        struct rt_ipc_object parent;        /**< 继承自 ipc_object 类*/
        rt_uint16_t value;                  /**< 信号量的值，最大为 65535 */
    };
    typedef struct rt_semaphore *rt_sem_t;
   ```

### 4.常用信号量函数接口
1. 信号量创建
   1. `rt_sem_create()`
2. 信号量删除
   1. `rt_sem_delete()`
3. 信号量释放
   1. `rt_sem_release()`
4. 信号量获取
   1. `rt_sem_take()`

## 3.互斥量
### 1.基本概念
1. 互斥量是一种特殊的二值信号量，但是互斥量同时还支持互斥量所有权、递归访问、防止优先级翻转，而二值信号量是有导致优先级翻转的风险
2. 互斥量的两种状态:开锁，闭锁；
3. 互斥量常用于重要资源的保护，也可以用于线程的同步，但是任意时刻互斥锁只能由同一个线程持有，因此互斥锁的作用时间应该尽可能短，因此线程之间的同步用信号量更加优越；
4. 如同信号量一样，如果互斥锁被其他线程占用着，会导致其他申请该互斥锁的线程阻塞等待；
5. 优先级继承：
   1. 当一个优先级较低的线程占有着互斥量时，如果一个优先级更高的线程也申请访问该互斥量，则优先级更高的线程会阻塞等待互斥量的释放，
   2. 优先级低的线程的优先级会暂时修改成高优先级线程的优先级，待互斥量释放后，优先级再调整回原来的值，
   3. 通过优先级继承，可以防止优先级翻转的发生；
6. 优先级翻转:
   1. 假设有线程1，线程2，线程3，其优先级依次增大，线程1、线程3会访问同一个互斥量
   2. 当线程1占用着互斥量时，而线程3也想申请该互斥量，线程3只能阻塞等待线程1释放该互斥量
   3. 若在线程3阻塞等待着线程1释放互斥量时，线程2就绪，因为线程2优先级高于线程1，则会出现了线程2工作的情况
   4. 而线程2的优先级低于优先级3，这就是优先级翻转
   5. 优先级翻转的危害:可能会导致高优先级事件的丢失，影响系统的实时性
   6. 利用互斥量优先级继承的特点，可以避免优先级翻转事件的发生
   ！[优先级翻转示意图]()
7. 互斥量递归访问:
   1. 同一个线程多次访问同一个互斥量(不同线程不能同时访问互斥量)
   2. 互斥量控制块中存在计数值，用于统计当前线程的访问次数
   3. 若当前线程持续访问该互斥锁，即未完全开锁，其他线程都无法访问

### 2.互斥量控制块
1.  如同线程控制块的结构体，用于描述互斥量的基本特性
    ```c
    struct rt_mutex {
        struct rt_ipc_object parent;                /* 继承自 ipc_object 类 */
        rt_uint16_t value;                          /* 互斥量值，0/1 */
        rt_uint8_t original_priority;               /* 持有互斥量的线程原始优先级 */
        rt_uint8_t hold;                            /* 互斥量线程的持有次数 */
        struct rt_thread *owner;                    /* 当前持有互斥量的线程 */
    };
    typedef struct rt_mutex *rt_mutex_t;
    ```

### 3.信号量接口
1. 创建互斥量
   1. `rt_mutex_create`
2. 删除互斥量
   1. `rt_mutex_delete`
3. 释放互斥量
   1. `rt_mutex_release()`
4. 获取互斥量
   1. `rt_mutex_release()`


## 4.事件
### 1.基本概念
1. 事件是一种线程间通信的机制，用于线程间的同步，但是事件通信只能是事件类型通信，没有数据传输；
2. 与信号不同，事件通信可以实现一对多、多对多的同步；
3. 事件集合用一个32位无符号整型变量来表示，每一位表示一个事件，线程通过逻辑与/逻辑或与一个或者多个事件建立关联，形成一个事件集合；
4. 线程与事件的同步模型:
   1. 一对多同步:一个线程等待多个事件触发
   2. 多对多同步:多个线程等待多个事件触发
5. 事件无排队性，即多次向线程发送同一事件(如果线程未读走事件)，等效于只发送了一次事件
6. 允许多个线程对同一事件进行读写操作
7. 线程对事件信息的标记:读、写、清除
8. 接收事件
   1. 接收事件时，需要按照需求对事件进行接收
   2. 接收事件之后，需要使用`RT_EVENT_FLAG_CLEA`清除已接受到的事件类型
9. 发送事件
   1.  对指定事件写入指定的事件类型，设置事件集合set的对应事件位为1
   2.  可以一次性写多个事件类型
   3.  发送事件会触发线程调度(如果有等待事件)
10. 清除数据
    1.  根据参数事件和待清除事件类型，对事件的对应位进行清零操作

### 2.事件控制块
1. 如同线程控制块的结构体，用于描述事件的基本特性
   ```c
    struct rt_event {
        struct rt_ipc_object parent;
        rt_uint32_t set;                /**< 事件标志位 */
    };
    typedef struct rt_event *rt_event_t; /* rt_event_t 是指向事件结构体的指针 */
   ```

### 3.事件接口函数
1. 事件创建函数
   1. ` rt_event_create()`
2. 事件删除函数 
   1. `rt_event_delete()`
3. 事件发送函数 
   1. `rt_event_send()`
4. 事件接收函数
   1. `rt_event_recv()`

## 5.邮箱
### 1.基本概念
1. 互斥量是一种特殊的二值信号量，但是互斥量同时还支持互斥量所有权、递归访问、防止优先级翻转，而二值信号量是有导致优先级翻转的风险
2. 互斥量的两种状态:开锁，闭锁；
3. 互斥量常用于重要资源的保护，也可以用于线程的同步，但是任意时刻互斥锁只能由同一个线程持有，因此互斥锁的作用时间应该尽可能短，因此线程之间的同步用信号量更加优越；
4. 如同信号量一样，如果互斥锁被其他线程占用着，会导致其他申请该互斥锁的线程阻塞等待；
5. 优先级继承：
   1. 当一个优先级较低的线程占有着互斥量时，如果一个优先级更高的线程也申请访问该互斥量，则优先级更高的线程会阻塞等待互斥量的释放，
   2. 优先级低的线程的优先级会暂时修改成高优先级线程的优先级，待互斥量释放后，优先级再调整回原来的值，
   3. 通过优先级继承，可以防止优先级翻转的发生；
6. 优先级翻转:
   1. 假设有线程1，线程2，线程3，其优先级依次增大，线程1、线程3会访问同一个互斥量
   2. 当线程1占用着互斥量时，而线程3也想申请该互斥量，线程3只能阻塞等待线程1释放该互斥量
   3. 若在线程3阻塞等待着线程1释放互斥量时，线程2就绪，因为线程2优先级高于线程1，则会出现了线程2工作的情况
   4. 而线程2的优先级低于优先级3，这就是优先级翻转
   5. 优先级翻转的危害:可能会导致高优先级事件的丢失，影响系统的实时性
   6. 利用互斥量优先级继承的特点，可以避免优先级翻转事件的发生
   ！[优先级翻转示意图]()
7. 互斥量递归访问:
   1. 同一个线程多次访问同一个互斥量(不同线程不能同时访问互斥量)
   2. 互斥量控制块中存在计数值，用于统计当前线程的访问次数
   3. 若当前线程持续访问该互斥锁，即未完全开锁，其他线程都无法访问

### 2.互斥量控制块
1.  如同线程控制块的结构体，用于描述互斥量的基本特性
    ```c
    struct rt_mutex {
        struct rt_ipc_object parent;                /* 继承自 ipc_object 类 */
        rt_uint16_t value;                          /* 互斥量值，0/1 */
        rt_uint8_t original_priority;               /* 持有互斥量的线程原始优先级 */
        rt_uint8_t hold;                            /* 互斥量线程的持有次数 */
        struct rt_thread *owner;                    /* 当前持有互斥量的线程 */
    };
    typedef struct rt_mutex *rt_mutex_t;
    ```

### 3.信号量接口
1. 创建互斥量
   1. `rt_mutex_create`
2. 删除互斥量
   1. `rt_mutex_delete`
3. 释放互斥量
   1. `rt_mutex_release()`
4. 获取互斥量
   1. `rt_mutex_release()`


## 4.事件
### 1.基本概念
1. 


## 5.邮箱
### 1.基本概念
1. 邮箱在操作系统中也是一种常用的IPC通信方式，可以在线程与线程之间、中断与线程之间进行消息传递；
2. 与信号量和消息队列相比，其开销更低，效率更高，每封邮件只能容纳固定的4字节内容，若线程间传递比较大的消息时，可以把置项一个缓冲区的指针作为邮件发送到邮箱中；
3. 线程从邮箱中读取信息，如果邮箱中无邮件，读线程则会阻塞，直到邮箱中接收到新的邮件，正因为这个阻塞机制，中断不能从邮箱中读取邮件；
4. 线程或者中断都可以从往邮箱中发送邮件，如果邮箱的邮件已经满了之后，线程可以设置成阻塞发送邮件，待邮箱中的一个邮件被读走之后，线程则被唤醒发送邮件，因此中断不能使用这种方式发送邮件，同样也可以使用非阻塞的方式发送邮件。
5. 邮件支持FIFO排队方式与优先级排队，在创建邮箱时决定邮箱的读取方式；
6. 发送与接收邮件均支持超时机制；
7. 一个线程可以从任意一个邮箱队列中接收/发送邮件；
8. 多个线程可以向同一个邮箱接收/发送邮件；
9. 邮箱和消息队列十分相似，只是邮箱中邮件的大小只能固定容纳4字节内容，因此邮箱开销很小，效率更高。

### 2.邮箱控制块
1. 如同线程控制块的结构体，用于描述邮箱的基本特性
   ```c
   struct rt_mailbox {
      struct rt_ipc_object parent;        /* 内核对象类型 */
      rt_uint32_t *msg_pool;              /* 邮箱缓冲区开始地址 */
      rt_uint16_t size;                   /* 缓冲区大小 */
      rt_uint16_t entry;                  /* 邮件数目 */
      rt_uint16_t in_offset;              /* 进邮箱偏移地址 */
      rt_uint16_t out_offset;             /* 出邮箱偏移地址 */
      rt_list_t suspend_sender_thread;    /* 发送线程的挂起等待链表 */
   };
   typedef struct rt_mailbox *rt_mailbox_t;
   ```

### 3. 邮箱的接口函数
1. 邮箱创建函数
   1. `rt_mb_create()`
2. 邮箱删除函数
   1. `rt_mb_delete()`
3. 邮箱邮件发送函数(带阻塞发送)
   1. `rt_mb_send_wait()`
4. 邮箱邮件发送函数(非阻塞发送)
   1. `rt_mb_send ()`
5. 邮箱邮件接收函数
   1. `rt_mb_recv()`

