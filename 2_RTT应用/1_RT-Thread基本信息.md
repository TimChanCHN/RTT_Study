# RT_Thread应用(一)
## 1. RT-Thread启动流程
1. 方式1--全部部件(硬件、系统、各个线程)初始化完成，之后再启动RTOS
2. 方式2--全部部件初始化，再初始化初始线程，启动RTOS
   1. 初始线程用于创建其他线程，创建成功之后需要关闭初始线程
3. RT-Thread启动流程
   1. 初始化系统堆栈大小、中断向量表，并在`Reset_Handler`中进行系统初始化后开始跳去`main`函数
      1. 系统初始化`SystemInit`
         1. 设置系统时钟
         2. 中断向量表重定向至内部Flash
      2. 跳去`__main`函数
         1. `__main`为运行时库提供的函数
         2. 完成“段拷贝”，因为程序的加载地址和执行地址大概率不同(因为片内内存太小)
            1. `__scatterload()`:将非零（只读和读写）运行区域从其载入地址复制到运行地址(载入地址是RO，运行地址是RW), 清零ZI区域(未初始化变量区)
            2. `__rt_entry()`:负责初始化堆栈，完成库函数的初始化
   2. 完成`1.2.2`后程序会跳转到`component.c`的`$Sub$$main`(该函数是keil对main的扩展[对应宏`__CC_ARM`]，IAR和KEIL会有所区别)，在该函数中会进行启动rt-thread的工作
         1. 关中断
         2. rtthread_startup
   3. rtthread_startup：
      1. 关中断
      2. 硬件初始化:rt_hw_board_init
      3. 定时器初始化:rt_system_timer_init
      4. 调度器初始化:rt_system_scheduler_init
      5. 信号量初始化:rt_system_signal_init
      6. 创建初始线程(main在此处进去):rt_application_init
      7. 定时器线程初始化:rt_system_timer_thread_init
      8. 空闲线程初始化:rt_thread_idle_init
      9. 启动调度器:rt_system_scheduler_start
   4. rt_application_init
      1. 初始化初始线程，线程函数是:`main_thread_entry`
      2. 启动初始线程
   5. $Super$$main()
      1. 进入C程序的main函数中，其他线程就在main函数中启动

## 2. 线程创建
### 1.硬件初始化
1. 由启动流程可知，先进入函数`rtthread_startup`,硬件初始化函数`rt_hw_board_init`就在该函数中；
2. 在本项目的board.c中，可以查看到由改函数的定义，相关外设的初始化，可以放到该函数中处理；
3. 该函数作用:
   1. 初始化systick
   2. 初始化外设
   3. 初始化其他组件

### 2.静态内存创建线程
1. 定义线程函数:`static void func(void* parameter)`
2. 定义线程栈:`static rt_uint8_t rt_thread_stack[STACK_SIZE]`
3. 定义线程控制块:`static struct rt_thread xxx_thread`
4. 初始化线程:`rt_thread_init`
5. 启动线程:`rt_thread_startup(xxx_thread)`

### 3.动态内存创建线程
1. 在rtconfig.h使能宏`RT_USING_USER_MAIN`和`RT_USING_HEAP`,从而使能堆空间
2. 流程
   1. 定义线程控制块指针:`static rt_thread_t xxx_thread = RT_NULL`
   2. 定义线程函数:`static void func(void* parameter)`
   3. 创建线程--该函数会给线程控制块赋值空间:`xxx_thread = rt_thread_create()`
   4. 启动线程:`rt_thread_startup(xxx_thread)`
3. 创建线程的静态方式和动态方式
   1. 主要是在内存申请的方式有区别，静态方式是指申请一个全局的线程内存，而动态方式则是通过创建线程的方式获取

## 3. 重映射串口到rt_kprintf
1. rt_kprintf的作用同printf函数，该函数在`kservice.c`中实现，作用是把格式化的参数写入`rt_log_buf`这个buff中，之后通过函数`rt_hw_console_output`映射到串口中，同理还可以把该函数映射到其他终端上
2. 对函数`rt_hw_console_output`的改造
   1. 该函数的变量其实就是`rt_log_buf`
   2. 改造方向就是把变量中的Buff通过串口、CAN等终端发送出去

## 4.线程管理
### 1.线程
1. 从系统的角度看，线程是竞争系统资源的最小运行单元;
2. RTT的线程可以认为是一系列独立线程集合，每个线程在自己独立的环境中运行(有堆栈保证);
3. 通过上下文切换来保证各个线程环境不受干扰(由调度器实现);
4. RTT支持通过优先级来对内核进行抢占式使用，对同等优先级的线程则支持时间片论赚的方式来调度；
   1. 高优先级线程可以打断低优先级线程，低优先级线程必须把CPU控制权让位给高优先级线程。

## 2.RTT调度器
1. RTT调度器是基于优先级的全占式调度，除了中断、上锁部分代码、禁止中断部分代码不可抢占之外，其他都可以抢占；
2. 系统总共支持256个优先级，当有比当前线程的优先级更高的线程就绪时，当前线程会被立刻换出，高优先级线程抢占CPU运行；
3. 操作系统是否是实时操作系统的条件是：
   1. 支持优先级调度，高优先级线程一就绪就会立即获得处理器的控制权；
   2. 系统可以快速查找出当前系统优先级最高的线程的过程
      1. 如果采用链表遍历的方法，假如就绪的线程有n个，从而这个遍历过程直接和n相关，如果n足够大，在这个遍历链表的过程中会花掉足够多的时间，影响系统的实时性；
      2. RTT使用的是一种基于位图的优先级算法(时间复杂度O(1)),位图是指把0~255个优先级组对应的最高优先级存储到一个列表中，牺牲空间换取时间，保证系统的实时性；
4. 线程调度的原则是一旦线程状态发生了改变，并且当前运行的线程优先级小于优先级队列组中线程最高优先级时，立刻进行线程切换（除非当前系统处于中断处理程序中或禁止线程切换的状态）

### 3.线程状态
1. 线程的状态
   1. 初始态:创建线程时的初始状态
   2. 就绪态:存储在就绪列表中，并具备着执行能力，等待CPU
   3. 运行态:正在执行的线程，占用处理器
   4. 挂起态:正在等待某个时序或者中断的线程，该线程不在就绪列表中；线程被挂起、延时、等待信号量、读写队列或事件；
   5. 关闭态:线程运行结束，等待系统回收资源
2. 线程状态迁移
   1. 初始态->就绪态:线程创建后会进入初始态，在线程启动`rt_thread_startup`后会转变成就绪态
   2. 就绪态->运行态:线程切换时，就绪列表中优先级最高的线程会被执行，进入运行态
   3. 运行态->挂起态:正在运行的线程发生阻塞(挂起、延时、读信号量等)，线程会从就绪列表中删除，进入挂起态
   4. 挂起态->就绪态:阻塞的线程恢复后，线程会被加入到就绪列表中，挂起态会变成就绪态
   5. 就绪态->挂起态:类似于`3`
   6. 运行态->就绪态:更高优先级线程创建或者恢复后，发生的线程调度导致当前线程进入就绪态
   7. 挂起态->关闭态:挂起的线程被调用删除接口
   8. 运行态->关闭态:运行态的线程执行rt_thread_exit，从而进入关闭态
   ![RTT线程状态迁移]()
3. 常用线程函数
   1. 线程挂起
      1. `rt_thread_suspend`
   2. 线程恢复函数
      1. `rt_thread_resume`

### 4.线程设计要点
1. 掌握需求，确定线程的优先级信息，线程与中断的处理，线程的运行时间、逻辑、状态
2. 线程运行的上下文环境
   1. 中断服务函数
      1. 不能挂起当前线程(否则可能会引起死锁)
      2. 尽量只做事件标记，不做事件处理，否则会影响系统运行
   2. 线程
      1. 线程切换时会有上下文切换
      2. 线程中不能有死循环，否则无法调度到低优先级线程
      3. 紧急处理的事件线程优先级设置高一点
   3. 空闲线程
      1. 空闲线程不允许出现阻塞，因为系统需要始终都有一个可运行的线程
      2. 系统资源回收工作在空闲线程中实现
3. 线程的执行时间
   1. 线程从开始到结束的时间
   2. 线程的周期--要求实时响应的时间
   3. 例如：线程A的运行时间是10ms，线程B的运行时间是100us,线程C的运行时间50ms；如果线程B的优先级比A高，即使在A运行的过程中发生了B，对A几乎无影响，但如果线程C优先级比A高，则线程A有可能会被错过，从而影响系统实时性


## 疑问：
   1. rtthread_startup的调用函数是entry，但是未见哪里调用了entry?
      1. 该函数在`__main`执行结束后，编译器会自动调用。在MDK的编译器中，并不会直接执行entry，而是执行`$Sub$$main`，而entry是在其他编译环境下使用。
   2. 哪种做法导致了原来正点原子的库函数工程接入了rt-thread系统？

## 备注:
1. STM32内存区域说明:`https://blog.csdn.net/qq_31073871/article/details/102569983`
2. RO,RW,ZI区别:`https://blog.csdn.net/jamestaosh/article/details/4348385`
3. 同上:`https://www.cnblogs.com/luckytimor/p/7182629.html`

