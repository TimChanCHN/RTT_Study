# RT_Thread内核学习(3)
## 1. RTT多优先级
> RTT要支持多优先级，就需要靠就绪列表支持。就绪列表由`线程就绪优先级组`、`线程优先级表`组成。

### 1. 线程就绪优先级组
1. 线程就绪优先级组描述着各个优先级的是否存在线程，`调度器从就绪列表指定的索引中执行现线程`；
2. RTT通过线程就绪优先级组`rt_thread_ready_priority_group`可以快速定位当前优先级最高的线程
   1. 线程就绪优先级组是一个32bit的数字，每个bit代表着自己的优先级
   2. 通过数组`__lowest_bit_bitmap`可以快速定位当前的最高优先级的bit，可以把该表理解位哈希表，该表把0~255作为数组的索引，而对应的最高优先级所在的bit位数组内容，这种方法是用空间换事件的处理方法
   3. 数组`__lowest_bit_bitmap`只能用于查找8bit的最高优先级分布情况，当大于8位的时候，做相应的偏移即可

### 2. 线程优先级表
1. 线程优先级表就是之前所述的就绪列表`rt_thread_priority_table`，通过索引来确定线程的优先级，而在该目录下的第1个文件中，并没有做这种优先级处理，只是对就绪列表中的线程进行轮询处理而已；
2. 就绪列表的每个索引号对应着线程的优先级，每个索引下维护着一条双向链表，用于管理着当前优先级的线程，线程会根据优先级插入到对应索引的链表，优先级相同的列表会插入到同一条链表中，需要时间片来对同个优先级下的线程进行处理
3. 相关接口:
   1. 调度器插入线程
      1. `rt_schedule_insert_thread`
         1. 关闭中断，把当前线程控制块的状态成员stat更改成就绪态`RT_THREAD_READY`
         2. 把线程插入就绪列表中
         3. 设置线程就绪优先级组中对应的bit
         4. 开启中断
   2. 调度器删除线程
      1. `rt_schedule_remove_thread`
         1. 关中断
         2. 将线程从就绪列表中删除`rt_list_remove`
         3. 判断就绪列表中对应的优先级中管理的线程是否为空，是则把线程就绪优先级组对应的bit清空，否则说明该优先级下依然有需要继续执行的线程，不能把线程就绪优先级组清空
   
## 2. RTT定时器
### 1. 概念
1. RTT中的每个线程都内置着一个定时器，每当线程需要延时的时候，先将线程挂起转而启动内置的定时器；
2. RTT的定时器会插入到一个全局的系统定时器列表`rt_timer_list`中，该定时器列表维护者一条双向链表，每个节点代表着正在延时的线程的定时器，节点按照定时时间升序排列；
3. RTT定时器的扫描方式是，每来一次时基中断，就会对系统定时器列表进行扫描，如果第一个定时器延时事件不到的话则退出扫描，这是由于该链表的排序是按照定时时间升序排序的

### 2. 相关API
1. 系统定时器列表
   1. `rt_timer_list`:管理着需要延时的线程的定时器
2. 系统定时器列表初始化
   1. `rt_system_timer_init`:本质是对`rt_timer_list`中的全部节点赋值空节点
3. 定义定时器结构体
   1. ` struct rt_timer`
   ```c
    struct rt_timer
    {
        struct rt_object parent;            /* 从 rt_object 继承 */
        
        rt_list_t row[RT_TIMER_SKIP_LIST_LEVEL]; /* 节点 */ 
        
        void (*timeout_func)(void *parameter); /* 超时函数 */ 
        void *parameter; /* 超时函数形参 */ 
        
        rt_tick_t init_tick; /* 定时器实际需要延时的时间 */ 
        rt_tick_t timeout_tick; /* 定时器实际超时时的系统节拍数 */
     };
   ```
4. 定时器初始化函数
   1. `rt_timer_init`
      1. 初始化定时器对象
      2. 初始化定时器
5. 定时器删除函数
   1. `_rt_timer_remove`
      1. 把该定时器从系统定时器列表中删除
6. 定时器停止函数
   1. `rt_timer_stop`
      1. 将定时器从系统定时器列表中移除
      2. 设置定时器状态为非active
7. 定时器控制函数
   1. `rt_timer_control`
      1. 获取定时时间
      2. 设置定时时间
      3. 设置单次触发/周期触发
8. 定时器启动函数
   1. `rt_timer_start`
      1. 先将定时器从系统定时器列表中移除并设置其状态为非active
      2. 设置定时时间为:系统当前时间rt_tick+需要定时的时间
      3. 将定时器插入定时器列表，升序排序
      4. 设置定时器状态标志为激活，开中断，定时器启动
9. 定时器扫描函数
   1. 获取系统时基计数器的计数值
   2. 扫描系统定时器列表，判断第一个定时器是否到达定时时间，否则退出循环，结束函数
   3. 是则调用定时处理函数(令线程处于就绪列表)，并根据单次触发或周期触发做相应处理

## 3. RTT时间片
### 1. 概念
1. 如果当前系统中同时有两个优先级不同的线程，优先级高的线程会先执行，之后再执行优先级低的线程；
2. 如果当前系统中同时有两个优先级相同的线程，系统是如何运行？是通过时间片机制。通过给不同的线程分配不同的时间片，当线程A的时间片消耗完成后，则开始执行线程B，如此反复。

## 4. RTT实现调度流程
1. 在RTT中，通过线程来实现线程的处理，每个线程都有自己的线程控制块，包含着线程的基本信息：线程入口地址、定时时间、优先级、时间片长短、线程列表节点等等；
2. 利用线程就绪列表对不同优先级的线程进行管理，同个优先级是一个链表，链表的各个节点就是线程对应的节点；
3. 利用线程就绪优先级组来对系统当前的优先级分布情况进行管理，在32bit的中，数据越低的，优先级越高；在把线程插入线程就绪列表时，会对相应的线程就绪优先级组的bit进行置位；
4. 启动调度器后，调度器会先根据线程就绪优先级组中的最高优先级，然后遍历线程就绪列表中的链表，从而取出线程运行；
5. 时间片只对于相同优先级的线程才会有意义，对于两个优先级相同的线程，当分配给线程A的时间片消耗完的时候，则进行一次调度；
6. 由于RTT是可抢占式内核，当有更高优先级的线程就绪时，内核的使用权就被更高优先级的线程抢占，正在运行中的低优先级线程则会挂起；

### 其他
1.  上下文切换是指上文保存(保存旧线程的运行状态)和下文切换(把新线程的堆栈状态更新到当前CPU中)
2.  上下文切换的时候发生在中断或者线程切换
3.  如果是启动第一个线程时，则不需要做上文保存，只需要做下文切换，之后的所有线程的切换都需要进行一个完整的上下文切换过程。
